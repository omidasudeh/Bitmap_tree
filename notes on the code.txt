	////===================== actual bitmap query
	/*
	 *input: 
	 *	Pv: value-based predicate
	 *	Pd: dimension-based predicate
	 *	DimY: the length of the Y dimension
	 *output:
	 *	prints the query result
	 */
	//void aggregate_query(vector<pair<int, int>> Pv, vector<pair<int, int>> Pdx,vector<pair<int, int>> Pdy, int DimY);
	
	/*checks if interval b is completely within interval R*/
	//bool In(pair<int, int>b,pair<int, int> R);
	
	/*returns true if a bin b is fully selected by the value-based predicate Pv*/
	//bool overlap(pair<int, int> b, vector<pair<int,int>> Pv);
	
	/*translates the dimension based query into a bitvector predicate*/
	//vector<size_t> translate (vector<pair<int, int>> Pdx,vector<pair<int, int>> Pdy, int DimY);
	
	/*returns the approximate summation of the query*/
	/float approximate_sum(unordered_map<int,int> * count_array);
	//====================== tree Query =======================================
	/*calculates the overlap of the query region with the node region*/
	//pair<pair<int,int>, pair<int,int>>* spatial_overlap(int x1, int y1, int x2, int y2, pair<pair<int,int>, pair<int,int>>* node_region);
	/*calculates the node region based on the node number*/
	//pair<pair<int,int>, pair<int,int>>* get_node_region(int node_number);
	//int  Query(int x1, int y1, int x2, int y2, int DimX,int DimY);
	//int  TreeQuery(int x1, int y1, int x2, int y2,int node_number,pair<pair<int,int>, pair<int,int>>* node_region);
	
	/*it convertes the tree-index to actual bitmap-tree index*/
	//int bitmap_tree_index(int index);
==================================================
//=============================================  bitmap-tree Spatial Query =======================
template <class a_type>
pair<pair<int,int>, pair<int,int>>* BitVectorIndex<a_type>::get_node_region(int node_number)
{
	pair<pair<int,int>, pair<int,int>>* result = NULL;
	if(node_number<0)
		return result;
	result = new pair<pair<int,int>, pair<int,int>>;
	int level  = log(3*node_number+1)/log(4);
	int i_level = node_number-(pow(4,level)-1)/3;
	int t = pow(2,level);
	//cout<<"here"<<endl;
	int X_L = i_level/2;
	int Y_L = i_level%2;
	//cout<<"node_number:"<<node_number<<"   level:"<<level<<"   i_level:"<<i_level<<"   X_L:"<<X_L<<"    Y_L:"<<Y_L<<"  ceil((DimX-1)/t) "<< ceil((float)(DimX-1)/t)<<" ceil((DimY-1))/t "<< ceil((float)(DimY-1)/t)<<endl;
	//assert(false);
	int X1 = 0, Y1 = 0;
	//int N = actual_data_count-1;//!!! TODO: update ============> what if tree is not perfect
	//cout<<N<<endl;
	if (node_number!=0)
	{
		
		X1 = ceil((float)(DimX-1)/t)*X_L;
		Y1 = ceil((float)(DimY-1)/t)*Y_L;

	}
	int X2 = X1+ floor((float)(DimX-1)/t); 
	int Y2 = Y1+ floor((float)(DimY-1)/t);
	//cout<<"(X1: "<<X1<<", Y1: "<<Y1<<" X2: "<<X2<<", Y2: "<<Y2<<")"<<endl;
	pair<int,int> top_left;
	pair<int,int> bottom_right;	
	top_left.first = X1;
	top_left.second = Y1;
	bottom_right.first = X2;
	bottom_right.second = Y2;
	
	result->first = top_left;
	result->second = bottom_right;
	return result;
}
/* returns the value of the node 
	input: node_number
	output: the bin <min,max> values as a pair<int,int>; returns NULL if the value is not in none of the bins
*/
template <class a_type>
pair<int,int> * BitVectorIndex<a_type>:: get_node_value(int node_number)
{
	k0++;
	pair<int,int>* result = NULL; 
	
	int chunk_number = node_number/chunk_size;
	int chunk_index = node_number%chunk_size;
	
	
	////naive  setbit compression
	boost::dynamic_bitset<>bit_chunk_index(chunk_size);
	bit_chunk_index.set(chunk_index);
	
	clock_t tq = clock();
	////////////////////////////// Bottle neck if chunk size is high !!!!!!!!!!!!!!!!!!!!!!!!!!!!
	vector<size_t>comp_chunk_index = compressBitset(bit_chunk_index); 
	gtt += clock()-tq;
	
	
	//for(auto w:comp_chunk_index)
		//cout<<hex<<w<<"	";
	//cout<<endl<<endl<<dec;	
	
	/*
    ////1. fast setbit compression=====================	
	//// make a bitvector with the chuck_index bit set and then compress it to comp_chunk_index
	
		 vector<size_t> comp_chunk_index;	 
		 int HZero = chunk_index - chunk_index%31;
		 if(HZero>0)
		 {
			size_t HZeroW = 0x80000000 + HZero;
			comp_chunk_index.push_back(HZeroW);
		 }
		 int OneW=0;
		 if(chunk_index<31)
			 OneW = 1<<chunk_index-(node_number-HZero)-1;
		 else
			 OneW = 1<<31-(node_number-HZero)-1;
		 comp_chunk_index.push_back(OneW);
		 
		 int LZero = chunk_index-HZero-31;
		 if(LZero>0)
		 {
			size_t LZeroW = 0x80000000 + LZero;
			comp_chunk_index.push_back(LZeroW);
		 }
	*/ 
	
	////2. check bitvectors ============================
	//// iterates over the bitvectors in the bitmap 
	//// and returns the bitvector statistics if the 
	//// chuck_index bit is set 
	
	
	int number_of_bins = (*first_level_bitmap).size();
	for(int bitvector_index = number_of_bins-1;bitvector_index>=0;bitvector_index--)
	{ 
		//clock_t tq = clock();
		//bool t = isInBitvector(bitvector_index,chunk_number, comp_chunk_index);
		//gtt += clock()-tq;
		if(isInBitvector(bitvector_index,chunk_number, comp_chunk_index))
		{
			////== retun bin.stat ==
			result = new pair<int,int>;
			result->first = (*firstlevelvalue)[bitvector_index].min_val/numpres;
			result->second= (*firstlevelvalue)[bitvector_index].max_val/numpres;
			
			return result;
			
		}
	}
	if (result == NULL) 
	{
			cout<<"Error: the node value was not found in the bitmap!\n";
			assert(false);
	}
	return result; 
}
template <class a_type>
bool BitVectorIndex<a_type>:: isInBitvector(int bitvector_index, int chunk_number, vector<size_t>& comp_chunk_index)
{	
 ////  logic_and the compressed bin with the comp_chunk_index and check if result.any()
		
		////1.======== logic_and
		//cout<<comp_chunk_index.size()<<"&"<<(*first_level_bitmap)[bitvector_index][chunk_number].size()<<endl;		
		////////////////////////////// Bottle neck!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		//clock_t tq = clock();
		//k0++;
		vector<size_t> comp_and_result = logic_and_ref(comp_chunk_index,(*first_level_bitmap)[bitvector_index][chunk_number]); // do assignment by reference
		//gtt += clock()-tq;
		
		////2.======== result.any()
		for(size_t word : comp_and_result) //if(compressed_and_result.any())
		{
			int WType = word_type(word);
			if( WType == 0 || WType == 2)// if the word is literal or ones fill word 
				return true;
				
		}
		return false;
}
template <class a_type>
pair<pair<int,int>, pair<int,int>>* BitVectorIndex<a_type>::spatial_overlap(int x1, int y1, int x2, int y2,pair<pair<int,int>, pair<int,int>>* node_region)
{
	
	pair<pair<int,int>, pair<int,int>>* result = NULL;
	pair<int,int> top_left;
	pair<int,int> bottom_right;
	//cout<<"overlap get region---| "<<endl;
	//cout<<"---------------------|\n"<<endl;
	int X1 = node_region->first.first;
	int Y1 = node_region->first.second;
	int X2 = node_region->second.first;
	int Y2 = node_region->second.second;
	//cout<<"overlap("<<x1<<","<<y1<<" "<<x2<<","<<y2<<") over ("<<X1<<","<<Y1<<" "<<X2<<","<<Y2<<")"<<endl;
	top_left.first = (x1>X1)?x1:X1;//max(x1,X1)
	top_left.second = (y1>Y1)?y1:Y1;//max(y1,Y1)
	bottom_right.first = (x2<=X2)?x2:X2;//min(x2,X2)
	bottom_right.second = (y2<=Y2)?y2:Y2;//min(y2,Y2)
	if(bottom_right.first<top_left.first || bottom_right.second<top_left.second ) // no overlap between query region and node area
	{
		return NULL;
	}
	result = new pair<pair<int,int>, pair<int,int>>;
	result->first.first = top_left.first;
	result->first.second = top_left.second;
	result->second.first = bottom_right.first;
	result->second.second = bottom_right.second;
	return result;
	
}
template <class a_type>
int BitVectorIndex<a_type>:: Query(int x1, int y1, int x2, int y2, int DX,int DY)
{
	//actual_data_count = data_count;
	DimX = DX;
	DimY = DY;
	pair<pair<int,int>, pair<int,int>>* root_region = new pair<pair<int,int>, pair<int,int>>;
	root_region->first.first   = 0;
	root_region->first.second  = 0;	
	root_region->second.first  = DimX-1;
	root_region->second.second = DimY-1;
	
	k0=0;
	gtt = 0;
	//clock_t tq = clock(); 
	int result = TreeQuery(x1, y1, x2, y2,0,root_region);
	//gtt += clock()-tq;
	cout<<"\ngtt:"<<gtt<<endl;
	cout<<"# of getvals:"<<k0<<endl;
	return result;
}
template <class a_type>
int BitVectorIndex<a_type>:: TreeQuery(int x1, int y1, int x2, int y2, int node_number,pair<pair<int,int>, pair<int,int>>* node_region)
{

	int X1 = node_region->first.first;
	int Y1 = node_region->first.second;
	int X2 = node_region->second.first;
	int Y2 = node_region->second.second;
	if(TRACE)
		cout<<"\nApprox. Query("<<x1<<","<<y1<<" "<<x2<<","<<y2<<") over ("<<X1<<","<<Y1<<" "<<X2<<","<<Y2<<")"<<endl;	
	
	if(x1 == X1 && y1 == Y1 && x2 == X2 && y2 == Y2) // base case: if the query region match the node area
	{
		//clock_t tq = clock(); /////bottle neck!!!!!!!!!!!!!!!!!!!!
		pair<int,int>* node_min_max = get_node_value(node_number);// get the bin statistic e.g. : [min:2,max: 10]
		//gtt += clock()-tq;
					
		if(TRACE)
			cout<<"GetVal of the node#"<<node_number<<"   "<<node_min_max->first<<"   "<<node_min_max->second<<endl;
		 
		int node_value =  (node_min_max->first+node_min_max->second)/2;// assumption: represent the bin with the mid value of the bin range e.g. (2+10)/2=6

		return node_value;
	}
	
	int r1 = 0;
	int r2 = 0;
	int r3 = 0;
	int r4 = 0;
	
	pair<pair<int,int>, pair<int,int>>* a1 = NULL;
	pair<pair<int,int>, pair<int,int>>* a2 = NULL;
	pair<pair<int,int>, pair<int,int>>* a3 = NULL;
	pair<pair<int,int>, pair<int,int>>* a4 = NULL;
	
	/*calculate the node number of the children*/
	if(TRACE)
		cout<<"father:"<<node_number<<endl;
	int first_child_tree_index = 4*node_number+1;
	int first_child = bitmap_tree_index(first_child_tree_index);
	if(TRACE)
		cout<<"first_child_tree_index:"<<first_child_tree_index<<"first_child:"<<first_child<<endl;
	
	int second_child_tree_index= 4*node_number+2;
	int second_child = bitmap_tree_index(second_child_tree_index);
	if(TRACE)
		cout<<"2nd_child_tree_index:"<<second_child_tree_index<<"second_child:"<<second_child<<endl;
	
	int third_child_tree_index = 4*node_number+3;
	int third_child = bitmap_tree_index(third_child_tree_index);
	if(TRACE)
		cout<<"third_child_tree_index:"<<third_child_tree_index<<"third_child:"<<third_child<<endl;
	
	int forth_child_tree_index = 4*node_number+4;
	int forth_child = bitmap_tree_index(forth_child_tree_index);
	if(TRACE)
		cout<<"forth_child_tree_index:"<<forth_child_tree_index<<"forth_child:"<<forth_child<<endl;
	
	//===========================================
	/*calculate the node region of the children*/
	int XMid = (X1+X2)/2;
	int YMid = (Y1+Y2)/2;
	pair<pair<int,int>, pair<int,int>>* first_child_region = new pair<pair<int,int>, pair<int,int>> ;//(x1,y1,xMid,yMid)
	first_child_region->first.first   = X1;
	first_child_region->first.second  = Y1;	
	first_child_region->second.first  = XMid;
	first_child_region->second.second = YMid;
	pair<pair<int,int>, pair<int,int>>* second_child_region = new pair<pair<int,int>, pair<int,int>>;//x1,yMid+1,xMid,y2
	second_child_region->first.first   = X1;
	second_child_region->first.second  = YMid+1;	
	second_child_region->second.first  = XMid;
	second_child_region->second.second = Y2;
	pair<pair<int,int>, pair<int,int>>* third_child_region = new pair<pair<int,int>, pair<int,int>>;//(xMid+1,y1, x2,yMid)
	third_child_region->first.first   = XMid+1;
	third_child_region->first.second  = Y1;	
	third_child_region->second.first  = X2;
	third_child_region->second.second = YMid;
	pair<pair<int,int>, pair<int,int>>* forth_child_region = new pair<pair<int,int>, pair<int,int>>;//(xMid+1,yMid+1,x2,y2);
	forth_child_region->first.first   = XMid+1;
	forth_child_region->first.second  = YMid+1;	
	forth_child_region->second.first  = X2;
	forth_child_region->second.second = Y2;
	//==========================================
	
	
	//cout<<"child1:"<<first_child<<"    child2:"<<second_child<<"    child3:"<<third_child<<"   child4:"<<forth_child<<endl;
	//if(node->first!=NULL)
		a1 = spatial_overlap(x1, y1, x2, y2, first_child_region);
	//cout<<"here0"<<endl;
	//if(node->second!=NULL)
		a2 = spatial_overlap(x1, y1, x2, y2, second_child_region);
	//cout<<"here1"<<endl;
	//if(node->third!=NULL)
		a3 = spatial_overlap(x1, y1, x2, y2, third_child_region);
	//cout<<"here2"<<endl;
	//if(node->forth!=NULL)
		a4 = spatial_overlap(x1, y1, x2, y2, forth_child_region);
	//cout<<a1<<" "<<a2<<" "<<a3<<" "<<a4<<endl;

	if(a1!=NULL)
	{
		r1 = TreeQuery((a1->first).first,(a1->first).second,(a1->second).first,(a1->second).second, first_child,first_child_region);
	}
	
	/*else
		cout<<"a1 is null"<<endl;*/
	
	if(a2!=NULL)
	{
				r2 = TreeQuery((a2->first).first,(a2->first).second,(a2->second).first,(a2->second).second, second_child,second_child_region);
	}/*
	else
		cout<<"a2 is null"<<endl;*/
		
	if(a3!=NULL)
	{
		r3 = TreeQuery((a3->first).first,(a3->first).second,(a3->second).first,(a3->second).second, third_child,third_child_region);
	}
	
	/*else
		cout<<"a3 is null"<<endl;*/
	if(a4!=NULL)
	{
		r4 = TreeQuery((a4->first).first,(a4->first).second,(a4->second).first,(a4->second).second, forth_child,forth_child_region);
	}
	/*else
		cout<<"a4 is null"<<endl;*/
	return r1+r2+r3+r4;
}
template <class a_type>
/*given the node number in the actual tree it will return the node number in the bitmap tree*/
int BitVectorIndex<a_type>:: bitmap_tree_index(int node_number)
{
	//test_count();
	//assert(false);
	
	/*
	////naive based count on compressed bit_representor
	boost::dynamic_bitset<> shifted_bit_representator;
	int shifts = Bit_representator.size()-node_number-1;
	shifted_bit_representator = Bit_representator<<(shifts);
	int ones = shifted_bit_representator.count()-1;
	return ones;
	*/
	
	/*
	//fast count on compressed bit_representor
	//cout<<"compressed_Bit_representator.size:"<<compressed_Bit_representator.size()<<endl;
	//clock_t tq = clock(); 	
		
	int ones = CountOnesUpto(compressed_Bit_representator,node_number);
	//gtt+=clock()-tq;

	return ones;
	*/
	return node_number;
}

==================================================
template <class a_type>
void BitVectorIndex<a_type>::aggregate_query(vector<pair<int, int>> Pv, vector<pair<int, int>> Pdx,vector<pair<int, int>> Pdy, int DimY)
{
	//=============== value based filtering
	/*TODO: candidacy check for the border bins; this code only selects the fully selected bins */
	vector<int> value_based_filtered_bins;
	int i = 0;
	for(auto elem:*firstlevelvalue)
	{
		if(overlap(pair<int, int>(elem.min_val, elem.max_val),Pv))
		{
			value_based_filtered_bins.push_back(i);			
		}
		i++;
	}
	cout<<"overlap bins (value_based_filtered_bins): ";
	for(int b:value_based_filtered_bins)
		cout<<b<<",";
	cout<<endl;
	
	//============== dimension based filtering
	vector<size_t> transalted_pd = translate(Pdx, Pdy, DimY);
	boost::dynamic_bitset<> pd(itemsCount,transalted_pd[0]);
	cout<<"trs_pd: "<< pd<<endl;
	unordered_map<int,int>* count_array = new unordered_map<int,int>;
	for(int bin_number:value_based_filtered_bins)
	{
		//cout<<(*firstlevelvectors)[bin_number][0];
		boost::dynamic_bitset<> bin(itemsCount,(*firstlevelvectors)[bin_number][0]);
		cout<<"bin"<<bin_number<<":   "<<bin<<endl;
		
		vector<size_t> result = logic_and((*firstlevelvectors)[bin_number],transalted_pd);
		boost::dynamic_bitset<> bit_result(itemsCount,result[0]);
		cout<<"result: "<<bit_result<<endl;
		count_array->insert(pair<int, int> (bin_number,bit_result.count()));
	}
	for (auto elem:*count_array)
		cout<<"bin"<<elem.first<<" count:"<<elem.second<<"	";
	cout<<endl;
	cout<<"approximate_sum without candidacy check: " <<approximate_sum(count_array)<<endl;
		
}
template <class a_type>
float BitVectorIndex<a_type>::approximate_sum(unordered_map<int,int> * count_array)
{
	float approx_sum = 0.0;
		for(auto elem:*count_array)
		{
			float key = (float)elem.first;
			float count = (float)elem.second;
			float stat_sum = (float)first_level_statistics[key].sum;
			float stat_count = (float)first_level_statistics[key].count;
			approx_sum+=stat_sum*(count/stat_count);
			cout<<approx_sum<<"	";
		}
	return approx_sum;
}
/*checks if b is fully inside R*/
template <class a_type>
bool BitVectorIndex<a_type>:: In(pair<int, int>b,pair<int, int> R)
{
	cout<<"check if "<<b.first/numpres<<","<<b.second/numpres<<" is in "<<R.first<<","<<R.second<<": "<<((b.first/numpres)>=R.first && (b.second/numpres) <= R.second)<<endl;
	return((b.first/numpres)>=R.first && (b.second/numpres) <= R.second);
}


template <class a_type>
bool BitVectorIndex<a_type>::overlap(pair<int, int> b, vector<pair<int,int>> Pv)
{
	for(auto R: Pv)
	{

		if(((b.second/numpres)>=R.first) && ((b.first/numpres)<=R.second))
			return true;
	}
	return false;
}

/*translates the dimension based query into a bitve
	boost::dynamic_bitset<> pd(itemsCount);// make an output bitvector of the size of the input data
	for(auto x_pair:Pdx )// for each partial range of x-dimension in the query
	{
		int x1 = x_pair.first;
		int x2 = x_pair.second;
		for(auto y_pair: Pdy)//for each partial range of ranges of y-dimension in the query
		{
			int y1 = y_pair.first;
			int y2 = y_pair.second;
			for(int i = x1;i<=x2;i++)// sweep the x-axis
			{
				for(int j= y1;j<=y2;j++)// sweep the y-axis
				{
					//cout<<"i:"<<i<<" j:"<<j<<endl;
					pd[i*DimY+j]=1;
				}
				
			}
		}
	}
	//cout<<pd<<endl;
	return compressBitset(pd);
}
//=============================================  bitmap-tree Spatial Query =======================
template <class a_type>
pair<pair<int,int>, pair<int,int>>* BitVectorIndex<a_type>::get_node_region(int node_number)
{
	pair<pair<int,int>, pair<int,int>>* result = NULL;
	if(node_number<0)
		return result;
	result = new pair<pair<int,int>, pair<int,int>>;
	int level  = log(3*node_number+1)/log(4);
	int i_level = node_number-(pow(4,level)-1)/3;
	int t = pow(2,level);
	//cout<<"here"<<endl;
	int X_L = i_level/2;
	int Y_L = i_level%2;
	//cout<<"node_number:"<<node_number<<"   level:"<<level<<"   i_level:"<<i_level<<"   X_L:"<<X_L<<"    Y_L:"<<Y_L<<"  ceil((DimX-1)/t) "<< ceil((float)(DimX-1)/t)<<" ceil((DimY-1))/t "<< ceil((float)(DimY-1)/t)<<endl;
	//assert(false);
	int X1 = 0, Y1 = 0;
	//int N = actual_data_count-1;//!!! TODO: update ============> what if tree is not perfect
	//cout<<N<<endl;
	if (node_number!=0)
	{
		
		X1 = ceil((float)(DimX-1)/t)*X_L;
		Y1 = ceil((float)(DimY-1)/t)*Y_L;

	}
	int X2 = X1+ floor((float)(DimX-1)/t); 
	int Y2 = Y1+ floor((float)(DimY-1)/t);
	//cout<<"(X1: "<<X1<<", Y1: "<<Y1<<" X2: "<<X2<<", Y2: "<<Y2<<")"<<endl;
	pair<int,int> top_left;
	pair<int,int> bottom_right;	
	top_left.first = X1;
	top_left.second = Y1;
	bottom_right.first = X2;
	bottom_right.second = Y2;
	
	result->first = top_left;
	result->second = bottom_right;
	return result;
}
/* returns the value of the node 
	input: node_number
	output: the bin <min,max> values as a pair<int,int>; returns NULL if the value is not in none of the bins
*/
template <class a_type>
pair<int,int> * BitVectorIndex<a_type>:: get_node_value(int node_number)
{
	k0++;
	pair<int,int>* result = NULL; 
	
	int chunk_number = node_number/chunk_size;
	int chunk_index = node_number%chunk_size;
	
	
	////naive  setbit compression
	boost::dynamic_bitset<>bit_chunk_index(chunk_size);
	bit_chunk_index.set(chunk_index);
	
	clock_t tq = clock();
	////////////////////////////// Bottle neck if chunk size is high !!!!!!!!!!!!!!!!!!!!!!!!!!!!
	vector<size_t>comp_chunk_index = compressBitset(bit_chunk_index); 
	gtt += clock()-tq;
	
	
	//for(auto w:comp_chunk_index)
		//cout<<hex<<w<<"	";
	//cout<<endl<<endl<<dec;	
	
	/*
    ////1. fast setbit compression=====================	
	//// make a bitvector with the chuck_index bit set and then compress it to comp_chunk_index
	
		 vector<size_t> comp_chunk_index;	 
		 int HZero = chunk_index - chunk_index%31;
		 if(HZero>0)
		 {
			size_t HZeroW = 0x80000000 + HZero;
			comp_chunk_index.push_back(HZeroW);
		 }
		 int OneW=0;
		 if(chunk_index<31)
			 OneW = 1<<chunk_index-(node_number-HZero)-1;
		 else
			 OneW = 1<<31-(node_number-HZero)-1;
		 comp_chunk_index.push_back(OneW);
		 
		 int LZero = chunk_index-HZero-31;
		 if(LZero>0)
		 {
			size_t LZeroW = 0x80000000 + LZero;
			comp_chunk_index.push_back(LZeroW);
		 }
	*/ 
	
	////2. check bitvectors ============================
	//// iterates over the bitvectors in the bitmap 
	//// and returns the bitvector statistics if the 
	//// chuck_index bit is set 
	
	
	int number_of_bins = (*first_level_bitmap).size();
	for(int bitvector_index = number_of_bins-1;bitvector_index>=0;bitvector_index--)
	{ 
		//clock_t tq = clock();
		//bool t = isInBitvector(bitvector_index,chunk_number, comp_chunk_index);
		//gtt += clock()-tq;
		if(isInBitvector(bitvector_index,chunk_number, comp_chunk_index))
		{
			////== retun bin.stat ==
			result = new pair<int,int>;
			result->first = (*firstlevelvalue)[bitvector_index].min_val/numpres;
			result->second= (*firstlevelvalue)[bitvector_index].max_val/numpres;
			
			return result;
			
		}
	}
	if (result == NULL) 
	{
			cout<<"Error: the node value was not found in the bitmap!\n";
			assert(false);
	}
	return result; 
}
template <class a_type>
bool BitVectorIndex<a_type>:: isInBitvector(int bitvector_index, int chunk_number, vector<size_t>& comp_chunk_index)
{	
 ////  logic_and the compressed bin with the comp_chunk_index and check if result.any()
		
		////1.======== logic_and
		//cout<<comp_chunk_index.size()<<"&"<<(*first_level_bitmap)[bitvector_index][chunk_number].size()<<endl;		
		////////////////////////////// Bottle neck!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		//clock_t tq = clock();
		//k0++;
		vector<size_t> comp_and_result = logic_and_ref(comp_chunk_index,(*first_level_bitmap)[bitvector_index][chunk_number]); // do assignment by reference
		//gtt += clock()-tq;
		
		////2.======== result.any()
		for(size_t word : comp_and_result) //if(compressed_and_result.any())
		{
			int WType = word_type(word);
			if( WType == 0 || WType == 2)// if the word is literal or ones fill word 
				return true;
				
		}
		return false;
}
template <class a_type>
pair<pair<int,int>, pair<int,int>>* BitVectorIndex<a_type>::spatial_overlap(int x1, int y1, int x2, int y2,pair<pair<int,int>, pair<int,int>>* node_region)
{
	
	pair<pair<int,int>, pair<int,int>>* result = NULL;
	pair<int,int> top_left;
	pair<int,int> bottom_right;
	//cout<<"overlap get region---| "<<endl;
	//cout<<"---------------------|\n"<<endl;
	int X1 = node_region->first.first;
	int Y1 = node_region->first.second;
	int X2 = node_region->second.first;
	int Y2 = node_region->second.second;
	//cout<<"overlap("<<x1<<","<<y1<<" "<<x2<<","<<y2<<") over ("<<X1<<","<<Y1<<" "<<X2<<","<<Y2<<")"<<endl;
	top_left.first = (x1>X1)?x1:X1;//max(x1,X1)
	top_left.second = (y1>Y1)?y1:Y1;//max(y1,Y1)
	bottom_right.first = (x2<=X2)?x2:X2;//min(x2,X2)
	bottom_right.second = (y2<=Y2)?y2:Y2;//min(y2,Y2)
	if(bottom_right.first<top_left.first || bottom_right.second<top_left.second ) // no overlap between query region and node area
	{
		return NULL;
	}
	result = new pair<pair<int,int>, pair<int,int>>;
	result->first.first = top_left.first;
	result->first.second = top_left.second;
	result->second.first = bottom_right.first;
	result->second.second = bottom_right.second;
	return result;
	
}
template <class a_type>
int BitVectorIndex<a_type>:: Query(int x1, int y1, int x2, int y2, int DX,int DY)
{
	//actual_data_count = data_count;
	DimX = DX;
	DimY = DY;
	pair<pair<int,int>, pair<int,int>>* root_region = new pair<pair<int,int>, pair<int,int>>;
	root_region->first.first   = 0;
	root_region->first.second  = 0;	
	root_region->second.first  = DimX-1;
	root_region->second.second = DimY-1;
	
	k0=0;
	gtt = 0;
	//clock_t tq = clock(); 
	int result = TreeQuery(x1, y1, x2, y2,0,root_region);
	//gtt += clock()-tq;
	cout<<"\ngtt:"<<gtt<<endl;
	cout<<"# of getvals:"<<k0<<endl;
	return result;
}
template <class a_type>
int BitVectorIndex<a_type>:: TreeQuery(int x1, int y1, int x2, int y2, int node_number,pair<pair<int,int>, pair<int,int>>* node_region)
{

	int X1 = node_region->first.first;
	int Y1 = node_region->first.second;
	int X2 = node_region->second.first;
	int Y2 = node_region->second.second;
	if(TRACE)
		cout<<"\nApprox. Query("<<x1<<","<<y1<<" "<<x2<<","<<y2<<") over ("<<X1<<","<<Y1<<" "<<X2<<","<<Y2<<")"<<endl;	
	
	if(x1 == X1 && y1 == Y1 && x2 == X2 && y2 == Y2) // base case: if the query region match the node area
	{
		//clock_t tq = clock(); /////bottle neck!!!!!!!!!!!!!!!!!!!!
		pair<int,int>* node_min_max = get_node_value(node_number);// get the bin statistic e.g. : [min:2,max: 10]
		//gtt += clock()-tq;
					
		if(TRACE)
			cout<<"GetVal of the node#"<<node_number<<"   "<<node_min_max->first<<"   "<<node_min_max->second<<endl;
		 
		int node_value =  (node_min_max->first+node_min_max->second)/2;// assumption: represent the bin with the mid value of the bin range e.g. (2+10)/2=6

		return node_value;
	}
	
	int r1 = 0;
	int r2 = 0;
	int r3 = 0;
	int r4 = 0;
	
	pair<pair<int,int>, pair<int,int>>* a1 = NULL;
	pair<pair<int,int>, pair<int,int>>* a2 = NULL;
	pair<pair<int,int>, pair<int,int>>* a3 = NULL;
	pair<pair<int,int>, pair<int,int>>* a4 = NULL;
	
	/*calculate the node number of the children*/
	if(TRACE)
		cout<<"father:"<<node_number<<endl;
	int first_child_tree_index = 4*node_number+1;
	int first_child = bitmap_tree_index(first_child_tree_index);
	if(TRACE)
		cout<<"first_child_tree_index:"<<first_child_tree_index<<"first_child:"<<first_child<<endl;
	
	int second_child_tree_index= 4*node_number+2;
	int second_child = bitmap_tree_index(second_child_tree_index);
	if(TRACE)
		cout<<"2nd_child_tree_index:"<<second_child_tree_index<<"second_child:"<<second_child<<endl;
	
	int third_child_tree_index = 4*node_number+3;
	int third_child = bitmap_tree_index(third_child_tree_index);
	if(TRACE)
		cout<<"third_child_tree_index:"<<third_child_tree_index<<"third_child:"<<third_child<<endl;
	
	int forth_child_tree_index = 4*node_number+4;
	int forth_child = bitmap_tree_index(forth_child_tree_index);
	if(TRACE)
		cout<<"forth_child_tree_index:"<<forth_child_tree_index<<"forth_child:"<<forth_child<<endl;
	
	//===========================================
	/*calculate the node region of the children*/
	int XMid = (X1+X2)/2;
	int YMid = (Y1+Y2)/2;
	pair<pair<int,int>, pair<int,int>>* first_child_region = new pair<pair<int,int>, pair<int,int>> ;//(x1,y1,xMid,yMid)
	first_child_region->first.first   = X1;
	first_child_region->first.second  = Y1;	
	first_child_region->second.first  = XMid;
	first_child_region->second.second = YMid;
	pair<pair<int,int>, pair<int,int>>* second_child_region = new pair<pair<int,int>, pair<int,int>>;//x1,yMid+1,xMid,y2
	second_child_region->first.first   = X1;
	second_child_region->first.second  = YMid+1;	
	second_child_region->second.first  = XMid;
	second_child_region->second.second = Y2;
	pair<pair<int,int>, pair<int,int>>* third_child_region = new pair<pair<int,int>, pair<int,int>>;//(xMid+1,y1, x2,yMid)
	third_child_region->first.first   = XMid+1;
	third_child_region->first.second  = Y1;	
	third_child_region->second.first  = X2;
	third_child_region->second.second = YMid;
	pair<pair<int,int>, pair<int,int>>* forth_child_region = new pair<pair<int,int>, pair<int,int>>;//(xMid+1,yMid+1,x2,y2);
	forth_child_region->first.first   = XMid+1;
	forth_child_region->first.second  = YMid+1;	
	forth_child_region->second.first  = X2;
	forth_child_region->second.second = Y2;
	//==========================================
	
	
	//cout<<"child1:"<<first_child<<"    child2:"<<second_child<<"    child3:"<<third_child<<"   child4:"<<forth_child<<endl;
	//if(node->first!=NULL)
		a1 = spatial_overlap(x1, y1, x2, y2, first_child_region);
	//cout<<"here0"<<endl;
	//if(node->second!=NULL)
		a2 = spatial_overlap(x1, y1, x2, y2, second_child_region);
	//cout<<"here1"<<endl;
	//if(node->third!=NULL)
		a3 = spatial_overlap(x1, y1, x2, y2, third_child_region);
	//cout<<"here2"<<endl;
	//if(node->forth!=NULL)
		a4 = spatial_overlap(x1, y1, x2, y2, forth_child_region);
	//cout<<a1<<" "<<a2<<" "<<a3<<" "<<a4<<endl;

	if(a1!=NULL)
	{
		r1 = TreeQuery((a1->first).first,(a1->first).second,(a1->second).first,(a1->second).second, first_child,first_child_region);
	}
	
	/*else
		cout<<"a1 is null"<<endl;*/
	
	if(a2!=NULL)
	{
				r2 = TreeQuery((a2->first).first,(a2->first).second,(a2->second).first,(a2->second).second, second_child,second_child_region);
	}/*
	else
		cout<<"a2 is null"<<endl;*/
		
	if(a3!=NULL)
	{
		r3 = TreeQuery((a3->first).first,(a3->first).second,(a3->second).first,(a3->second).second, third_child,third_child_region);
	}
	
	/*else
		cout<<"a3 is null"<<endl;*/
	if(a4!=NULL)
	{
		r4 = TreeQuery((a4->first).first,(a4->first).second,(a4->second).first,(a4->second).second, forth_child,forth_child_region);
	}
	/*else
		cout<<"a4 is null"<<endl;*/
	return r1+r2+r3+r4;
}
template <class a_type>
/*given the node number in the actual tree it will return the node number in the bitmap tree*/
int BitVectorIndex<a_type>:: bitmap_tree_index(int node_number)ctor predicate*/
template <class a_type>
vector<size_t> BitVectorIndex<a_type>::translate (vector<pair<int, int>> Pdx,vector<pair<int, int>> Pdy, int DimY)
{
	boost::dynamic_bitset<> pd(itemsCount);// make an output bitvector of the size of the input data
	for(auto x_pair:Pdx )// for each partial range of x-dimension in the query
	{
		int x1 = x_pair.first;
		int x2 = x_pair.second;
		for(auto y_pair: Pdy)//for each partial range of ranges of y-dimension in the query
		{
			int y1 = y_pair.first;
			int y2 = y_pair.second;
			for(int i = x1;i<=x2;i++)// sweep the x-axis
			{
				for(int j= y1;j<=y2;j++)// sweep the y-axis
				{
					//cout<<"i:"<<i<<" j:"<<j<<endl;
					pd[i*DimY+j]=1;
				}
				
			}
		}
	}
	//cout<<pd<<endl;
	return compressBitset(pd);
}

